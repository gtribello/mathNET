<PAGE>
  <TITLE> Ising Model Monte Carlo </TITLE>
  <WELCOME>
     This exercise will teach you how Monte Carlo simulations work.  You will, through the course of the 
     exercise, learn how to write your own Monte Carlo code for simulating a one dimensional closed Ising Model.
  </WELCOME>
  <SLIDERS>
    <div id="nslider">
      Number of spins: <input id="slide" type="range" min="5" max="100" step="5" value="25" onchange="myApp.setNumberOfSpins(this.value)"/> 
    </div>
    <div id="hslider">
      Magnetic field strength: <input id="slide" type="range" min="-5" max="5" step="1" value="0" onchange="myApp.setMagneticField(this.value)"/>
    </div>
    <div id="tslider">
      Temperature:  <input id="slide" type="range" min="0" max="10" step="1" value="1" onchange="myApp.setTemperature(this.value)"/> 
    </div>
  </SLIDERS>
  <WORKSPACE>
    <canvas id="myCanvas" width="400" height="400"></canvas>
  </WORKSPACE>
  <APIFUNCTIONS>
    // Add API functions for number of spins
    var wrapper = function(){
      return interpreter.createPrimitive(myApp.getNumberOfSpins());
    };
    interpreter.setProperty(scope, 'getNumberOfSpins', interpreter.createNativeFunction(wrapper));

    // Add API functions for magnetic field strength
    var wrapper = function(){
      return interpreter.createPrimitive(myApp.getMagneticField());
    };
    interpreter.setProperty(scope, 'getMagneticField', interpreter.createNativeFunction(wrapper));
   
    // Add API function for setting spins
    var wrapper = function(ida, idb){
      ida = ida ? ida.toString() : '';
      idb = idb ? idb.toString() : '';
      return interpreter.createPrimitive(myApp.setSpinValue(ida,idb));
    };
    interpreter.setProperty(scope, 'setSpinValue', interpreter.createNativeFunction(wrapper));
   
    // Add API function for getting spins
    var wrapper = function(id){
      id = id ? id.toString() : '';
      return interpreter.createPrimitive(myApp.getSpinValue(id));
    };
    interpreter.setProperty(scope, 'getSpinValue', interpreter.createNativeFunction(wrapper))
 
    // Add API function for printing energy
    var wrapper = function(id){
      id = id ? id.toString() : '';
      return interpreter.createPrimitive(myApp.printEnergy(id));
    };
    interpreter.setProperty(scope, 'printEnergy', interpreter.createNativeFunction(wrapper)) 
  </APIFUNCTIONS>
  <BLOCKS>
    // Return the magnetic field strength
    Blockly.Blocks["get_field"] = {
      init: function() {
        this.jsonInit({
          "message0": "get magnetic field strength",
          "output": "Number",
          "colour": Blockly.Blocks.variables.HUE,
          "tooltip": Blockly.Msg.VARIABLES_SET_TOOLTIP,
          "helpUrl": Blockly.Msg.VARIABLES_SET_HELPURL
        })
      }
    };
   
    Blockly.JavaScript['get_field'] = function(block) {
      var code = 'getMagneticField()';
      return [code, Blockly.JavaScript.ORDER_ATOMIC];
    };
   
    Blockly.Python['get_field'] = function(block) {
      var code = 'magnetic_field_strength';
      return [code, Blockly.Python.ORDER_ATOMIC];
    };

    // Return the number of spins in the system
    Blockly.Blocks["get_nspins"] = {
      init: function() {
        this.jsonInit({
          "message0": "number of spins",
          "output": "Number",
          "colour": Blockly.Blocks.variables.HUE,
          "tooltip": Blockly.Msg.VARIABLES_SET_TOOLTIP,
          "helpUrl": Blockly.Msg.VARIABLES_SET_HELPURL
        })
      }
    };
    
    Blockly.JavaScript['get_nspins'] = function(block) {
      var code = 'getNumberOfSpins()';
      return [code, Blockly.JavaScript.ORDER_ATOMIC];
    };
    
    Blockly.Python['get_nspins'] = function(block) {
      var code = 'nspins';
      return [code, Blockly.Python.ORDER_ATOMIC];
    };
    
    // Get the value of the ith spin
    Blockly.Blocks["get_spin"] = {
      // take input and plot it on y
      init: function() {
        this.jsonInit({
          "message0": "get spin %1",
          "args0": [
            {
              "type": "input_value",
              "name": "n",
              "check": "Number"
            }
          ],
          "output": "Number",
          "colour": Blockly.Blocks.variables.HUE,
          "tooltip": Blockly.Msg.VARIABLES_SET_TOOLTIP,
          "helpUrl": Blockly.Msg.VARIABLES_SET_HELPURL
        })
      }
    };
    
    Blockly.JavaScript['get_spin'] = function(block) {
      var s = Blockly.JavaScript.valueToCode(block, 'n', Blockly.JavaScript.ORDER_ATOMIC) || '0';
      var code = 'getSpinValue(' + s  + ')';
      return [code, Blockly.JavaScript.ORDER_ATOMIC];
    };
    
    Blockly.Python['get_spin'] = function(block) {
      var s = Blockly.Python.valueToCode(block, 'n', Blockly.Python.ORDER_ATOMIC) || '0';
      var code = 'spins[' + s  + ']';
      return [code, Blockly.Python.ORDER_ATOMIC];
    };
    
    Blockly.Blocks["set_spin"] = {
      init: function() {
        this.jsonInit({
          "message0": "set spin %1",
          "args0": [
            {
              "type": "input_value",
              "name": "n",
              "check": "Number"
            }
          ],
          "message1": " to %1",
          "args1": [
            {
              "type": "input_value",
              "name": "v",
              "check": "Number"
            }
          ],
          "inputsInline": true,
          "nextStatement": null,
          "previousStatement": null,
          "colour": Blockly.Blocks.variables.HUE,
          "tooltip": Blockly.Msg.VARIABLES_SET_TOOLTIP,
          "helpUrl": Blockly.Msg.VARIABLES_SET_HELPURL
        })
      }
    };
    
    Blockly.JavaScript['set_spin'] = function(block) {
      var s = Blockly.JavaScript.valueToCode(block, 'n', Blockly.JavaScript.ORDER_ATOMIC) || '0';
      var v = Blockly.JavaScript.valueToCode(block, 'v', Blockly.JavaScript.ORDER_ATOMIC) || '0';
      var code = 'setSpinValue(' + s + ',' + v + ');\n';
      return code;
    };
    
    Blockly.Python['set_spin'] = function(block) {
      var s = Blockly.Python.valueToCode(block, 'n', Blockly.Python.ORDER_ATOMIC) || '0';
      var v = Blockly.Python.valueToCode(block, 'v', Blockly.Python.ORDER_ATOMIC) || '0';
      var code = 'spins[' + s + '] = ' + v + '\n';
      return code;
    };

    Blockly.Blocks["print_energy"] = {
      init: function() {
        this.jsonInit({
          "message0": "print energy %1",
          "args0": [
            {
              "type": "input_value",
              "name": "n",
              "check": "Number"
            }
          ],
          "inputsInline": true,
          "nextStatement": null,
          "previousStatement": null,
          "colour": Blockly.Blocks.variables.HUE,
          "tooltip": Blockly.Msg.VARIABLES_SET_TOOLTIP,
          "helpUrl": Blockly.Msg.VARIABLES_SET_HELPURL
        })
      }
    };

    Blockly.JavaScript['print_energy'] = function(block) {
      var s = Blockly.JavaScript.valueToCode(block, 'n', Blockly.JavaScript.ORDER_ATOMIC) || '0';
      var code = 'printEnergy(' + s + ');\n';
      return code;
    };

    Blockly.Python['print_energy'] = function(block) {
      var s = Blockly.Python.valueToCode(block, 'n', Blockly.Python.ORDER_ATOMIC) || '0';
      var code = 'print("Energy equals",' + s + ')\n';
      return code;
    };
  </BLOCKS>
  <SCRIPTS>
    myApp.spins = new Array(); 
    myApp.magneticFieldStrength = 0;
    myApp.mismatchedEnergy = false;

    myApp.printEnergy = function( eng ){
      ctx.beginPath();
      ctx.moveTo( 100,100 );
      ctx.lineTo( 100,300 );
      ctx.lineTo( 300,300 );
      ctx.lineTo( 300,100 );
      ctx.lineTo( 100,100 );
      ctx.closePath();
      ctx.fillStyle = '#FFFFFF';
      ctx.fill(); 
      energy = -myApp.spins[0]*myApp.spins[myApp.spins.length-1] - myApp.spins[0]*myApp.magneticFieldStrength;
      for(var i = 1; i &lt; myApp.spins.length; i++){
          energy += -myApp.spins[i-1]*myApp.spins[i] - myApp.magneticFieldStrength*myApp.spins[i];
      }
      if( energy != eng ){ myApp.mismatchedEnergy = true; }
      ctx.fillStyle = '#000000';
      ctx.font="20px Georgia";
      ctx.fillText("Energy equals " + eng,110,180);
    };

    myApp.drawSpin = function( snum ){
      ctx = document.getElementById("myCanvas").getContext("2d");
      if ( ctx==null ){ return; }
      var num = parseInt( snum );

      ctx.beginPath(); var unit = 2*Math.PI/myApp.spins.length; var radius=200; var infr=0.9;
      ctx.moveTo(radius+radius*Math.cos((num+1)*unit),radius+radius*Math.sin((num+1)*unit));
      ctx.lineTo(radius+infr*radius*Math.cos((num+1)*unit),radius+infr*radius*Math.sin((num+1)*unit));
      ctx.lineTo(radius+infr*radius*Math.cos(num*unit),radius+infr*radius*Math.sin(num*unit));
      ctx.lineTo(radius+radius*Math.cos(num*unit),radius+radius*Math.sin(num*unit));
      ctx.closePath();

      if( myApp.spins[num]==0 ){
         ctx.stroke();
         return;
      }
      if (myApp.spins[num] == 1 ) {
         ctx.fillStyle = '#8ED6FF';
      } else {
         ctx.fillStyle = '#FF0000';
      }
      ctx.stroke();
      ctx.fill();
   };
  
   myApp.getSpinValue=function( n ) {
     if( n&gt;=this.spins.length || n &lt; 0 ){
         alert( "spin " + n + " does not exist" );
     }
     return this.spins[n];
   };

   myApp.setSpinValue=function( n, val ) {
     if( n>=this.spins.length || n &lt; 0 ){
         alert( "spin " + n + " does not exist" );
     }
     if( val!=1 &amp;&amp; val!=-1 ){
         alert( val + " is not a valid spin value" );
     }
     myApp.spins[n] = val;
     myApp.drawSpin( n );
   };

   myApp.setNumberOfSpins=function( nspins ) {
      myApp.spins = []; ctx = document.getElementById("myCanvas").getContext("2d");
      if( ctx!=null ){ ctx.clearRect(0,0,400,400); }
      for(var i = 0; i &lt; nspins; i++){ myApp.spins.push( 0 ); }
      for(var i = 0; i &lt; nspins; i++){ myApp.drawSpin( i ); }
   }; 
   myApp.getNumberOfSpins=function() {
     return myApp.spins.length;
   };
   myApp.setMagneticField=function(val) {
     myApp.magneticFieldStrength = val; 
   };
   myApp.getMagneticField=function() {
     return myApp.magneticFieldStrength;
   };
  </SCRIPTS>
  <STARTUP>
    myApp.setNumberOfSpins(25);
    myApp.setMagneticField(0);
  </STARTUP>
  <LEVEL>
    <DESCRIPTION>
      Use the blocks provided to set the microscopic coordinates of all the spins in the system equal to 1 
    </DESCRIPTION>
    <TOOLBOX>
      <category name="Variables" custom="VARIABLE"></category>
      <category name="Program">
         <block type="controls_repeat_ext"></block>
         <block type="math_arithmetic"></block>
         <block type="math_number"></block>
      </category>
      <category name="Microstate">
         <block type="get_nspins"></block>
         <block type="set_spin"></block>
      </category>
    </TOOLBOX>
    <FINISH>
       levelcomplete=true;
       for(var i=0; i &lt; myApp.spins.length; i++ ){
           if( myApp.spins[i]!=1 ){ levelcomplete=false; }
       }
    </FINISH>
  </LEVEL>
  <LEVEL>
    <DESCRIPTION>
      Use the blocks provided to set the microscopic coordinates of all the odd numbered spins in the system to 1 and all the even 
      numbered spins in the system to -1.  
    </DESCRIPTION>
    <TOOLBOX>
      <category name="Variables" custom="VARIABLE"></category>
      <category name="Program">
         <block type="controls_repeat_ext"></block>
         <block type="math_arithmetic"></block>
         <block type="math_number"></block>
      </category>
      <category name="Logic">
        <block type="controls_if"></block>
        <block type="logic_compare"></block>
        <block type="math_number_property"></block>
      </category>
      <category name="Microstate">
         <block type="get_nspins"></block> 
         <block type="set_spin"></block>
      </category>
    </TOOLBOX>
    <FINISH>
       levelcomplete=true;
       for(var i=0; i &lt; myApp.spins.length; i++ ){
           if( i%2==0 &amp;&amp; myApp.spins[i]!=-1 ){ levelcomplete=false; }
           if( i%2==1 &amp;&amp; myApp.spins[i]!=1 ){ levelcomplete=false; }
       }
    </FINISH>
  </LEVEL>
  <LEVEL>
    <DESCRIPTION>
      Use the blocks provided to generate a random configuration for the microscopic coordinates of all the spins.
    </DESCRIPTION>
    <TOOLBOX>
      <category name="Variables" custom="VARIABLE"></category>
      <category name="Program">
         <block type="controls_repeat_ext"></block>
         <block type="math_arithmetic"></block>
         <block type="math_number"></block>
      </category>
      <category name="Logic">
        <block type="controls_if"></block>
        <block type="logic_compare"></block>
        <block type="math_number_property"></block>
      </category>
      <category name="Microstate">
         <block type="get_nspins"></block>
         <block type="set_spin"></block>
      </category>
      <category name="Random">
         <block type="uniform_random"></block>
      </category>
    </TOOLBOX>
    <FINISH> 
       levelcomplete=false;
       ww = myApp.workspace.getAllBlocks(); 
       for(var i=0; i &lt; ww.length; i++ ){
           if( ww[i]=="uniform random variable between 0 and 1" ){ levelcomplete=true; }
       }
       for(var i=0; i &lt; myApp.spins.length; i++ ){
           if( myApp.spins[i]!=-1 &amp;&amp; myApp.spins[i]!=1 ){ levelcomplete=false; }
       }
    </FINISH>
  </LEVEL>
  <LEVEL>
    <DESCRIPTION>
      Use the blocks provided to generate a random configuration for the microscopic coordinates of all the spins.
      Then select one of the spin coordinates at random and flip the value of this spin.
    </DESCRIPTION>
    <TOOLBOX>
      <category name="Variables" custom="VARIABLE"></category>
      <category name="Program">
         <block type="controls_repeat_ext"></block>
         <block type="math_arithmetic"></block>
         <block type="math_number"></block>
         <block type="math_round"></block>
      </category>
      <category name="Logic">
        <block type="controls_if"></block>
        <block type="logic_compare"></block>
        <block type="math_number_property"></block>
      </category>
      <category name="Microstate">
         <block type="get_nspins"></block>
         <block type="set_spin"></block>
         <block type="get_spin"></block>
      </category>
      <category name="Random">
         <block type="uniform_random"></block>
      </category>
    </TOOLBOX>
    <FINISH>
       nuniform = 0;
       nsp_cal = 0
       ww = myApp.workspace.getAllBlocks();
       for(var i=0; i &lt; ww.length; i++ ){
           if( ww[i]=="uniform random variable between 0 and 1" ){ nuniform += 1; }
           if( ww[i]=="number of spins" ){ nsp_cal += 1; }
       }
       if( nuniform!=2 || nsp_cal!=2 ){ levelcomplete = false; }
       for(var i=0; i &lt; myApp.spins.length; i++ ){
           if( myApp.spins[i]!=-1 &amp;&amp; myApp.spins[i]!=1 ){ levelcomplete=false; }
       }
    </FINISH>
  </LEVEL>
 <LEVEL>
    <DESCRIPTION>
      Use the blocks provided to generate a random configuration for the microscopic coordinates of all the spins.
      Then make your code repeat the process of flipping one randomly chosen spin a total of 10 times.
    </DESCRIPTION>
    <TOOLBOX>
      <category name="Variables" custom="VARIABLE"></category>
      <category name="Program">
         <block type="controls_repeat_ext"></block>
         <block type="math_arithmetic"></block>
         <block type="math_number"></block>
         <block type="math_round"></block> 
      </category>
      <category name="Logic">
        <block type="controls_if"></block>
        <block type="logic_compare"></block>
        <block type="math_number_property"></block>
      </category>
      <category name="Microstate">
         <block type="get_nspins"></block>
         <block type="set_spin"></block>
         <block type="get_spin"></block>
      </category>
      <category name="Random">
         <block type="uniform_random"></block>
      </category>
    </TOOLBOX>
    <FINISH>
       ndo = 0;
       nuniform = 0;
       ww = myApp.workspace.getAllBlocks();
       for(var i=0; i &lt; ww.length; i++ ){
           if( ww[i]=="uniform random variable between 0 and 1" ){ nuniform += 1; }
           if( ww[i]="repeat" ){ ndo += 1; }
       }
       if( nuniform!=2 ||  ndo!=2 ){ levelcomplete = false; }
       for(var i=0; i &lt; myApp.spins.length; i++ ){
           if( myApp.spins[i]!=-1 &amp;&amp; myApp.spins[i]!=1 ){ levelcomplete=false; }
       }    
    </FINISH>
  </LEVEL>
  <LEVEL>
    <DESCRIPTION>
      At the end of the previous level we implemented a Monte Carlo integrator that accepted all moves and that therefore operated at infiite temperature.  To
      operate at finite temperature we are going to have to calculate the energy.  Use the blocks provided to generate a random configuration of spins and then  
      calculate the energy of this microstate using the Ising model Hamiltonian.  Once the energy has been calculated you 
      should report it to the screen using the print energy block.
    </DESCRIPTION>
    <TOOLBOX>
      <category name="Variables" custom="VARIABLE"></category>
      <category name="Program">
         <block type="controls_repeat_ext"></block>
         <block type="math_arithmetic"></block>
         <block type="math_number"></block>
      </category>
      <category name="Logic">
        <block type="controls_if"></block>
        <block type="logic_compare"></block>
        <block type="math_number_property"></block>
      </category>
      <category name="Microstate">
         <block type="get_nspins"></block>
         <block type="get_field"></block> 
         <block type="set_spin"></block>
         <block type="get_spin"></block>
         <block type="print_energy"></block>
      </category>
      <category name="Random">
         <block type="uniform_random"></block>
      </category>
    </TOOLBOX>
    <FINISH>
       levelcomplete=false;
       ww = myApp.workspace.getAllBlocks();
       for(var i=0; i &lt; ww.length; i++ ){
           if( ww[i]=="get magnetic field strength" ){ levelcomplete=true; }
       }
       for(var i=0; i &lt; myApp.spins.length; i++ ){
           if( myApp.spins[i]!=-1 &amp;&amp; myApp.spins[i]!=1 ){ levelcomplete=false; }
       } 
       if( myApp.mismatchedEnergy ){ levelcomplete=false; }
    </FINISH>
  </LEVEL>
  <LEVEL>
    <DESCRIPTION>
      Lets now generate a trajectory of 11 frames using what we learnt while programming the code for the last but one level.
      Calculate the energy using the Ising model Hamiltonian for each of the microstates you generate by flipping individual spins 
      and report these to screen.
    </DESCRIPTION>
    <TOOLBOX>
      <category name="Variables" custom="VARIABLE"></category>
      <category name="Program">
         <block type="controls_repeat_ext"></block>
         <block type="math_arithmetic"></block>
         <block type="math_number"></block>
         <block type="math_round"></block> 
      </category>
      <category name="Logic">
        <block type="controls_if"></block>
        <block type="logic_compare"></block>
        <block type="math_number_property"></block>
      </category>
      <category name="Microstate">
         <block type="get_nspins"></block>
         <block type="set_spin"></block>
         <block type="get_field"></block>
         <block type="get_spin"></block>
         <block type="print_energy"></block>
      </category>
      <category name="Random">
         <block type="uniform_random"></block>
      </category>
    </TOOLBOX>
    <FINISH>
       levelcomplete=false;
       ww = myApp.workspace.getAllBlocks();
       for(var i=0; i &lt; ww.length; i++ ){
           if( ww[i]=="get magnetic field strength" ){ levelcomplete=true; }
       }   
       for(var i=0; i &lt; myApp.spins.length; i++ ){
           if( myApp.spins[i]!=-1 &amp;&amp; myApp.spins[i]!=1 ){ levelcomplete=false; }
       }   
       if( myApp.mismatchedEnergy ){ levelcomplete=false; }
    </FINISH>
  </LEVEL>
  <LEVEL>
    <DESCRIPTION>
      The arrangement of blocks you should have just arrived at provides almost everything we need for our 
      Monte Carlo integrator.  Can you finish off the code by implementing the Metropolis accept/reject criteria as well.
      Make sure you only report the energies of the accepted configurations to screen.
    </DESCRIPTION>
    <TOOLBOX>
      <category name="Variables" custom="VARIABLE"></category>
      <category name="Program">
         <block type="controls_repeat_ext"></block>
         <block type="math_arithmetic"></block>
         <block type="math_number"></block>
         <block type="math_round"></block>
      </category>
      <category name="Logic">
        <block type="controls_if"></block>
        <block type="logic_compare"></block>
        <block type="math_number_property"></block>
      </category>
      <category name="Microstate">
         <block type="get_nspins"></block>
         <block type="set_spin"></block>
         <block type="get_spin"></block>
         <block type="print_energy"></block>
      </category>
     <category name="Random">
         <block type="uniform_random"></block>
      </category>
    </TOOLBOX>
    <FINISH>
       levelcomplete=false;
       ww = myApp.workspace.getAllBlocks();
       for(var i=0; i &lt; ww.length; i++ ){
           if( ww[i]=="get magnetic field strength" ){ levelcomplete=true; }
       }
       for(var i=0; i &lt; myApp.spins.length; i++ ){
           if( myApp.spins[i]!=-1 &amp;&amp; myApp.spins[i]!=1 ){ levelcomplete=false; }
       }
       if( myApp.mismatchedEnergy ){ levelcomplete=false; }
    </FINISH>
  </LEVEL>
</PAGE>
